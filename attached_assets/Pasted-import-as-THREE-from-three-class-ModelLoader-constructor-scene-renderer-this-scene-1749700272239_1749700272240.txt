import * as THREE from 'three';

class ModelLoader {
  constructor(scene, renderer) {
    this.scene = scene;
    this.renderer = renderer;
    this.loadingManager = new THREE.LoadingManager();
    this.textureLoader = new THREE.TextureLoader(this.loadingManager);
    this.gltfLoader = new THREE.GLTFLoader(this.loadingManager);
    
    // Loading progress tracking
    this.setupLoadingManager();
  }

  setupLoadingManager() {
    this.loadingManager.onLoad = () => {
      console.log('All assets loaded successfully');
      this.onLoadComplete && this.onLoadComplete();
    };

    this.loadingManager.onProgress = (url, itemsLoaded, itemsTotal) => {
      const progress = (itemsLoaded / itemsTotal) * 100;
      console.log(`Loading progress: ${progress.toFixed(1)}% (${url})`);
      this.onLoadProgress && this.onLoadProgress(progress, url);
    };

    this.loadingManager.onError = (url) => {
      console.error(`Failed to load: ${url}`);
      this.onLoadError && this.onLoadError(url);
    };
  }

  async loadSmallOfficeModel(modelPath, texturesConfig = {}) {
    try {
      // Load the GLTF model
      const gltf = await this.loadGLTF(modelPath);
      const model = gltf.scene;

      // Apply textures if model doesn't have them baked in
      if (Object.keys(texturesConfig).length > 0) {
        await this.applyTextures(model, texturesConfig);
      }

      // Optimize model
      this.optimizeModel(model);

      // Add to scene
      this.scene.add(model);

      return {
        model: model,
        animations: gltf.animations,
        cameras: gltf.cameras,
        scenes: gltf.scenes
      };

    } catch (error) {
      console.error('Error loading model:', error);
      throw error;
    }
  }

  loadGLTF(path) {
    return new Promise((resolve, reject) => {
      this.gltfLoader.load(
        path,
        (gltf) => resolve(gltf),
        (progress) => {
          const percent = (progress.loaded / progress.total) * 100;
          console.log(`Model loading: ${percent.toFixed(1)}%`);
        },
        (error) => reject(error)
      );
    });
  }

  async applyTextures(model, texturesConfig) {
    // Texture configuration example:
    // {
    //   'MaterialName': {
    //     map: 'path/to/diffuse.jpg',
    //     normalMap: 'path/to/normal.jpg',
    //     roughnessMap: 'path/to/roughness.jpg',
    //     metalnessMap: 'path/to/metalness.jpg',
    //     aoMap: 'path/to/ao.jpg'
    //   }
    // }

    const texturePromises = [];
    const loadedTextures = {};

    // Pre-load all textures
    for (const [materialName, textureData] of Object.entries(texturesConfig)) {
      for (const [textureType, texturePath] of Object.entries(textureData)) {
        if (texturePath && !loadedTextures[texturePath]) {
          texturePromises.push(
            this.loadTexture(texturePath).then(texture => {
              loadedTextures[texturePath] = texture;
              return { path: texturePath, texture };
            })
          );
        }
      }
    }

    // Wait for all textures to load
    await Promise.all(texturePromises);

    // Apply textures to materials
    model.traverse((child) => {
      if (child.isMesh && child.material) {
        const materialName = child.material.name || child.name;
        const textureData = texturesConfig[materialName];

        if (textureData) {
          this.applyTextureToMaterial(child.material, textureData, loadedTextures);
        }
      }
    });
  }

  loadTexture(path) {
    return new Promise((resolve, reject) => {
      this.textureLoader.load(
        path,
        (texture) => {
          // Configure texture settings
          texture.wrapS = THREE.RepeatWrapping;
          texture.wrapT = THREE.RepeatWrapping;
          texture.flipY = false; // Important for GLTF models
          
          // Enable anisotropic filtering for better quality
          texture.anisotropy = this.renderer.capabilities.getMaxAnisotropy();
          
          resolve(texture);
        },
        undefined,
        (error) => reject(error)
      );
    });
  }

  applyTextureToMaterial(material, textureData, loadedTextures) {
    // Convert to standard material if needed
    if (!(material instanceof THREE.MeshStandardMaterial)) {
      // Create new standard material preserving existing properties
      const standardMaterial = new THREE.MeshStandardMaterial({
        color: material.color || 0xffffff,
        transparent: material.transparent,
        opacity: material.opacity,
        side: material.side
      });
      
      // Replace the material
      material = standardMaterial;
    }

    // Apply textures
    if (textureData.map && loadedTextures[textureData.map]) {
      material.map = loadedTextures[textureData.map];
      material.needsUpdate = true;
    }

    if (textureData.normalMap && loadedTextures[textureData.normalMap]) {
      material.normalMap = loadedTextures[textureData.normalMap];
      material.normalScale = new THREE.Vector2(1, 1);
      material.needsUpdate = true;
    }

    if (textureData.roughnessMap && loadedTextures[textureData.roughnessMap]) {
      material.roughnessMap = loadedTextures[textureData.roughnessMap];
      material.roughness = 1.0; // Let the map control roughness
      material.needsUpdate = true;
    }

    if (textureData.metalnessMap && loadedTextures[textureData.metalnessMap]) {
      material.metalnessMap = loadedTextures[textureData.metalnessMap];
      material.metalness = 1.0; // Let the map control metalness
      material.needsUpdate = true;
    }

    if (textureData.aoMap && loadedTextures[textureData.aoMap]) {
      material.aoMap = loadedTextures[textureData.aoMap];
      material.aoMapIntensity = 1.0;
      material.needsUpdate = true;
    }

    if (textureData.emissiveMap && loadedTextures[textureData.emissiveMap]) {
      material.emissiveMap = loadedTextures[textureData.emissiveMap];
      material.emissive = new THREE.Color(0xffffff);
      material.needsUpdate = true;
    }

    return material;
  }

  optimizeModel(model) {
    model.traverse((child) => {
      if (child.isMesh) {
        // Enable shadow casting/receiving
        child.castShadow = true;
        child.receiveShadow = true;

        // Optimize geometry
        if (child.geometry) {
          child.geometry.computeBoundingBox();
          child.geometry.computeBoundingSphere();
          
          // Merge vertices if needed (be careful with this)
          // child.geometry.mergeVertices();
        }

        // Frustum culling optimization
        child.frustumCulled = true;
      }
    });

    // Compute bounding box for the entire model
    const box = new THREE.Box3().setFromObject(model);
    const center = box.getCenter(new THREE.Vector3());
    const size = box.getSize(new THREE.Vector3());

    console.log('Model bounds:', { center, size });

    return { center, size };
  }

  // Method to find and replace specific objects (like monitors/laptop)
  findObjectByName(model, name) {
    let foundObject = null;
    model.traverse((child) => {
      if (child.name === name) {
        foundObject = child;
      }
    });
    return foundObject;
  }

  // Method to hide/show objects
  setObjectVisibility(model, objectName, visible) {
    const object = this.findObjectByName(model, objectName);
    if (object) {
      object.visible = visible;
    }
  }

  // Method to get all object names for debugging
  getObjectNames(model) {
    const names = [];
    model.traverse((child) => {
      if (child.name) {
        names.push(child.name);
      }
    });
    return names;
  }
}

// Usage example
export class OfficePortfolioScene {
  constructor(canvas) {
    this.canvas = canvas;
    this.setupScene();
    this.setupLighting();
    this.modelLoader = new ModelLoader(this.scene, this.renderer);
    this.setupCallbacks();
  }

  setupScene() {
    // Scene
    this.scene = new THREE.Scene();
    this.scene.background = new THREE.Color(0x1a1a1a);

    // Camera
    this.camera = new THREE.PerspectiveCamera(
      60,
      window.innerWidth / window.innerHeight,
      0.1,
      1000
    );
    this.camera.position.set(5, 3, 5);

    // Renderer
    this.renderer = new THREE.WebGLRenderer({ 
      canvas: this.canvas,
      antialias: true 
    });
    this.renderer.setSize(window.innerWidth, window.innerHeight);
    this.renderer.shadowMap.enabled = true;
    this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    this.renderer.outputEncoding = THREE.sRGBEncoding;
    this.renderer.toneMapping = THREE.ACESFilmicToneMapping;
    this.renderer.toneMappingExposure = 1.0;
  }

  setupLighting() {
    // Ambient light
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
    this.scene.add(ambientLight);

    // Main directional light
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(10, 10, 5);
    directionalLight.castShadow = true;
    directionalLight.shadow.mapSize.width = 2048;
    directionalLight.shadow.mapSize.height = 2048;
    directionalLight.shadow.camera.near = 0.5;
    directionalLight.shadow.camera.far = 50;
    directionalLight.shadow.camera.left = -10;
    directionalLight.shadow.camera.right = 10;
    directionalLight.shadow.camera.top = 10;
    directionalLight.shadow.camera.bottom = -10;
    this.scene.add(directionalLight);

    // Fill light
    const fillLight = new THREE.DirectionalLight(0x4a90e2, 0.3);
    fillLight.position.set(-5, 3, -5);
    this.scene.add(fillLight);
  }

  setupCallbacks() {
    this.modelLoader.onLoadProgress = (progress, url) => {
      console.log(`Loading: ${progress.toFixed(1)}%`);
      // Update your loading UI here
    };

    this.modelLoader.onLoadComplete = () => {
      console.log('Model loaded successfully');
      // Hide loading screen, start animations, etc.
    };

    this.modelLoader.onLoadError = (url) => {
      console.error(`Failed to load: ${url}`);
      // Show error message to user
    };
  }

  async loadOfficeModel() {
    try {
      // Define texture configuration if textures aren't baked in
      const texturesConfig = {
        // Example texture mapping - adjust based on your model's material names
        'DeskMaterial': {
          map: '/textures/desk_diffuse.jpg',
          normalMap: '/textures/desk_normal.jpg',
          roughnessMap: '/textures/desk_roughness.jpg'
        },
        'FloorMaterial': {
          map: '/textures/floor_diffuse.jpg',
          normalMap: '/textures/floor_normal.jpg'
        },
        'WallMaterial': {
          map: '/textures/wall_diffuse.jpg'
        }
        // Add more materials as needed
      };

      // Load the model
      const modelData = await this.modelLoader.loadSmallOfficeModel(
        '/models/small-office.glb', // Adjust path as needed
        texturesConfig // Pass empty object {} if textures are baked in
      );

      this.officeModel = modelData.model;

      // Get object names for debugging
      console.log('Available objects:', this.modelLoader.getObjectNames(this.officeModel));

      // Hide built-in monitors/laptop if they exist so you can add custom ones
      this.modelLoader.setObjectVisibility(this.officeModel, 'Monitor1', false);
      this.modelLoader.setObjectVisibility(this.officeModel, 'Monitor2', false);
      this.modelLoader.setObjectVisibility(this.officeModel, 'Monitor3', false);
      this.modelLoader.setObjectVisibility(this.officeModel, 'Laptop', false);

      // Position and scale the model
      this.officeModel.position.set(0, 0, 0);
      this.officeModel.scale.set(1, 1, 1);

      // Look at the center of the model
      const bounds = new THREE.Box3().setFromObject(this.officeModel);
      const center = bounds.getCenter(new THREE.Vector3());
      this.camera.lookAt(center);

      return this.officeModel;

    } catch (error) {
      console.error('Failed to load office model:', error);
      throw error;
    }
  }

  animate() {
    requestAnimationFrame(() => this.animate());
    this.renderer.render(this.scene, this.camera);
  }

  handleResize() {
    this.camera.aspect = window.innerWidth / window.innerHeight;
    this.camera.updateProjectionMatrix();
    this.renderer.setSize(window.innerWidth, window.innerHeight);
  }
}

// Initialize the scene
export function initializePortfolio(canvas) {
  const portfolio = new OfficePortfolioScene(canvas);
  
  // Load the office model
  portfolio.loadOfficeModel()
    .then((model) => {
      console.log('Office model loaded successfully');
      // Add your custom monitors, laptop, and interactions here
    })
    .catch((error) => {
      console.error('Failed to initialize portfolio:', error);
    });

  // Start animation loop
  portfolio.animate();

  // Handle window resize
  window.addEventListener('resize', () => portfolio.handleResize());

  return portfolio;
}